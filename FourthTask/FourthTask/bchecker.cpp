#include "bchecker.h"
#include <stack>
#include <map>

/*
About stack
Класс stack является контейнером-адаптеров, реализующим функционал стека - в частности, структуру
данных (первый вошёл, последний вышел)

top - доступ к верхнему элементу
empty - проверяет отсутствие элементов в контейнере, используемом для реализации
size - возвращает количество элементов в контейнере
push - перебрасывает элемент на верх стека
pop - удаляет верхний элемент 
*/

/*bool BraceChecker::isBalanced(std::string& s) {
	std::stack<char> a;
	for (int i = 0; i < s.length(); i++) {
		if (!a.empty()) {
			if ( (s[i] == ')' && a.top() == '(') || (s[i] == '}' && a.top() == '{') || (s[i] == ']' && a.top() == '[') ) {
				a.pop();
				continue;
			}
		}
		a.push(s[i]); 
	}
	return a.empty();
}*/
/*
по сути, эта програма открывает коробку и забрасывает туда разыне скобки. Выкладывает она скобки только после того, как убедится в том,
что в коробке найдена праная скобка к текущей. В идеале, если всё сбалансировано, то в коробке станет пусто -> оператор empty для прооверки.
В противном случае,  если что-то останется в коробке, то строка не сбалансирована.
Алгортм воспринимает только строку из скобок разных форм. Если на входе сделать дополнительную проверку, то программу можно сделать универсальной.
Проверка на то, что в стек кладётся скобка или другое значение.

В итоге:
 Связываем работу строк и классов в С++
*/
/*
std::map<char,char> b = {{'(',')'}, {'{','}'}, {'[',']'}};
char next;
char ch = st.top();
if (b[ch]==next){
}
*/

std::map<char, char> br = {
		{'(',')'},
		{'[',']'},
		{'{','}'}
};

bool BraceChecker::isBalanced(std::string& s) {
	std::stack<char> a;
	for (int i = 0; i < s.length(); i++) {
		if (!a.empty()) {
			char ch = a.top();
			if (br[ch] == s[i]) {
				a.pop();
				continue;
			}
		}
		a.push(s[i]);
	}
	return a.empty();
}